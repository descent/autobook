\chapter{A Minimal GNU Autotools Project}\label{C_amgap}


This chapter describes how to manage a minimal project using the GNU Autotools. A minimal project is defined to be the smallest possible project that can still illustrate a sufficient number of principles in using the tools. By studying a smaller project, it becomes easier to understand the more complex interactions between these tools when larger projects require advanced features. 


The example project used throughout this chapter is a fictitious (虛構的) 
command interpreter called foonly. foonly is written in C, but like many 
interpreters, uses a lexical analyzer and a parser expressed using the lex 
and yacc tools. The package will be developed to adhere to (adhere to (黏附))
the GNU `Makefile' standard, which is the default behavior for Automake. 


There are many features of the GNU Autotools that this small project will not 
utilize (利用). The most noteworthy (值得注意的) one is libraries; this 
package does not produce 
any libraries of its own, so Libtool will not feature (起重要作用) in this 
chapter. The 
more complex projects presented in 
chapter \ref{C_A_Small_GNU_Autotools_Project} A 
Small GNU Autotools Project (page \pageref{C_A_Small_GNU_Autotools_Project}) and 
chapter \ref{C_A_Large_GNU_Autotools_Project} A Large GNU Autotools Project
(page \pageref{C_A_Large_GNU_Autotools_Project}) will 
illustrate how Libtool participates in the build system. The purpose of this chapter will be to provide a high-level overview of the user-written files and how they interact.

\section{User-Provided Input Files}


The smallest project requires the user to provide only two files. The 
remainder of the files needed to build the package are generated by the GNU 
Autotools (see section \ref{S_Generated_Output_Files} Generated Output Files,
page \pageref{S_Generated_Output_Files}). 

\begin{itemize}
\item `Makefile.am' is an input to automake. 
\item `configure.in' is an input to autoconf. 
\end{itemize}

I like to think of `Makefile.am' as a high-level, bare-bones (基礎)
specification (規格) of a project's build requirements: what needs to be 
built, and where does it go when it is installed? This is probably 
Automake's greatest strength--the description is about as simple as it 
could possibly be, yet the final product is a `Makefile' with an array (配置)
of convenient make targets. 


The `configure.in' is a template of macro invocations and shell code 
fragments that are used by autoconf\marginpar{configure.in 被 autoconf 使用}
to produce a `configure' script
(see section C. Generated File Dependencies). autoconf copies the 
contents of `configure.in' to `configure', expanding macros as they 
occur in the input. Other text is copied verbatim (逐字地). 


Let's take a look at (take a look at 看一看) the contents of the 
user-provided input files that are relevant to this minimal project. Here is the `Makefile.am': 

\begin{Verbatim}[frame=single]
bin_PROGRAMS = foonly
foonly_SOURCES = main.c foo.c foo.h nly.c scanner.l parser.y
foonly_LDADD = @LEXLIB@
\end{Verbatim}


This `Makefile.am' specifies that we want a program called `foonly' to 
be built and installed in the `bin' directory when make install is run.
The source files that are used to build `foonly' are the C source 
files `main.c', `foo.c', `nly.c' and `foo.h', the lex program 
in `scanner.l' and a yacc grammar in `parser.y'. This points out a 
particularly nice aspect about Automake: because lex and yacc both generate 
intermediate (中間的) C programs from their input files, Automake knows how 
to build 
such intermediate files and link them into the final executable. Finally,
we must remember to link a suitable lex library, if `configure' 
concludes (結束) that one is needed. 


And here is the `configure.in': 

\begin{Verbatim}[frame=single]
dnl Process this file with autoconf to produce a configure 
    script.
AC_INIT(main.c)
AM_INIT_AUTOMAKE(foonly, 1.0)
AC_PROG_CC
AM_PROG_LEX
AC_PROG_YACC
AC_OUTPUT(Makefile)
\end{Verbatim}

This `configure.in' invokes some mandatory (指令, 命令) Autoconf and 
Automake 
initialization macros, and then calls on some Autoconf macros from the 
AC\_{}PROG family to find suitable C compiler, lex, and yacc programs.
Finally, the AC\_{}OUTPUT macro is used to cause the generated `configure' 
script to output a `Makefile'---but from what? It is processed 
from `Makefile.in', which Automake produces for you based on 
your `Makefile.am' (see section C. Generated File Dependencies). 


\section{Generated Output Files}\label{S_Generated_Output_Files}


By studying the diagram in C. Generated File Dependencies, it should be 
possible to see which commands must be run to generate the required 
output files from the input files shown in the last section. 


First, we generate `configure': 

\begin{Verbatim}[frame=single]
$ aclocal
$ autoconf
\end{Verbatim}

Because `configure.in' contains macro invocations which are not known to 
autoconf itself -- AM\_{}INIT\_{}AUTOMAKE being a case in point
(case in point 恰當的例子), it is 
necessary to collect all of the macro definitions for autoconf to use 
when generating `configure'. This is done using the
aclocal\marginpar{aclocal 會產生 aclocal.m4, 所以如此命名} program, so 
called because it generates `aclocal.m4' (see section C. Generated File 
Dependencies). If you were to examine the contents of `aclocal.m4',
you would find the definition of the AM\_{}INIT\_{}AUTOMAKE macro 
contained within. 

After running autoconf, you will find a `configure' script in the current 
directory. It is important to run aclocal first because 
automake\marginpar{automake 需要 configure.in, aclocal.m4} relies on the contents of `configure.in' and `aclocal.m4'. On to automake: 

\begin{Verbatim}[frame=single]
$ automake --add-missing
automake: configure.in: installing ./install-sh
automake: configure.in: installing ./mkinstalldirs
automake: configure.in: installing ./missing
automake: Makefile.am: installing ./INSTALL
automake: Makefile.am: required file ./NEWS not found
automake: Makefile.am: required file ./README not found
automake: Makefile.am: installing ./COPYING
automake: Makefile.am: required file ./AUTHORS not found
automake: Makefile.am: required file ./ChangeLog not found
\end{Verbatim}

The `\verb+--add-missing+' option copies some boilerplate (照本宣科的規範)
files from your Automake installation into the current directory. Files such as `COPYING', which contain the GNU General Public License change 
infrequently (稀少地, 珍貴地), and so can be generated without user 
intervention (介入, 插入). A number of utility scripts are also
installed -- these are used by the generated `Makefile's,
particularly (特別, 尤其) by the install target. Notice that some required files are still missing. These are: 

\begin{description}
\item[`NEWS']
\ 

A record of user-visible changes to a package. The format is not strict, but the changes to the most recent version should appear at the top of the file. 

\item[`README']
\ 

The first place a user will look to get an overview for the purpose of 
a package, and perhaps special installation instructions. 

\item[`AUTHORS']
\ 

Lists the names, and usually mail addresses, of individuals who worked on the package. 

\item[`ChangeLog']
\ 

The ChangeLog is an important file--it records the changes that are made to a 
package. The format of this file is quite strict
(see section \ref{S_Documentation_and_ChangeLogs} Documentation and ChangeLogs,
page \pageref{S_Documentation_and_ChangeLogs}). 
\end{description}

For now, we'll do enough to placate (撫慰, 和解, 懷柔) Automake: 

\begin{Verbatim}[frame=single]
$ touch NEWS README AUTHORS ChangeLog
$ automake --add-missing
\end{Verbatim}


 Automake has now produced a `Makefile.in'. At this point, you may wish to take a snapshot of this directory before we really let loose with automatically generated files. 


By now, the contents of the directory will be looking fairly complete and
reminiscent (回憶往事的) of the top-level directory of a GNU package you may have installed in the past:

\begin{Verbatim}[frame=single]
AUTHORS   INSTALL     NEWS       install-sh   mkinstalldirs
COPYING   Makefile.am README     configure    missing 
ChangeLog Makefile.in aclocal.m4 configure.in
\end{Verbatim}



 It should now be possible to package up your tree in a tar file and give it to other users for them to install on their own systems. One of the make targets that Automake generates in `Makefile.in' makes it easy to generate distributions (see chapter \ref{C_Rolling_Distribution_Tarballs}
Rolling Distribution Tarballs, page \pageref{C_Rolling_Distribution_Tarballs}).
A user would merely have to unpack the tar file, run configure
(see chapter \ref{C_How_to_run_configure_and_make}
How to run configure and make, page \pageref{C_How_to_run_configure_and_make})
and finally type make all: 


\begin{Verbatim}[frame=single]
$ ./configure
creating cache ./config.cache
checking for a BSD compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking whether make sets ${MAKE}... yes
checking for working aclocal... found
checking for working autoconf... found
checking for working automake... found
checking for working autoheader... found
checking for working makeinfo... found
checking for gcc... gcc
checking whether the C compiler (gcc  ) works... yes
checking whether the C compiler (gcc  ) is a cross-compiler... 
         no
checking whether we are using GNU C... yes
checking whether gcc accepts -g... yes
checking how to run the C preprocessor... gcc -E
checking for flex... flex
checking for flex... (cached) flex
checking for yywrap in -lfl... yes
checking lex output file root... lex.yy
checking whether yytext is a pointer... yes
checking for bison... bison -y
updating cache ./config.cache
creating ./config.status
creating Makefile

$ make all
gcc -DPACKAGE=\"foonly\" -DVERSION=\"1.0\" -DYYTEXT_POINTER=1  
    -I. -I. -g -O2 -c main.c
gcc -DPACKAGE=\"foonly\" -DVERSION=\"1.0\" -DYYTEXT_POINTER=1  
    -I. -I. -g -O2 -c foo.c
flex   scanner.l && mv lex.yy.c scanner.c
gcc -DPACKAGE=\"foonly\" -DVERSION=\"1.0\" -DYYTEXT_POINTER=1  
    -I. -I. -g -O2 -c scanner.c
bison -y   parser.y && mv y.tab.c parser.c
if test -f y.tab.h; then \
  if cmp -s y.tab.h parser.h; then rm -f y.tab.h; \
  else mv y.tab.h parser.h; fi; \
else :; fi
gcc -DPACKAGE=\"foonly\" -DVERSION=\"1.0\" -DYYTEXT_POINTER=1  
    -I. -I. -g -O2 -c parser.c
gcc  -g -O2  -o foonly  main.o foo.o scanner.o parser.o -lfl 
\end{Verbatim}

\section{Maintaining Input Files}


If you edit any of the GNU Autotools input files in your package, it is necessary to regenerate the machine generated files for these changes to
take effect (take effect 見效, 生效). For instance, if you add a new source file to the foonly\_{}SOURCES variable in `Makefile.am'. It is necessary to re-generate the derived file `Makefile.in'. If you are building your package, you need to re-run configure to re-generate the site-specific `Makefile', and then re-run make to compile the new source file and link it into `foonly'. 


It is possible to regenerate these files by running the required tools,
one at a time (at a time 每次, 一次). However, as we can see above, it can be difficult to compute the dependencies--does a particular (特殊的) change require aclocal to be run? Does a particular change require autoconf to be run? There are two solutions to this problem. 


The first solution is to use the autoreconf command. This tool regenerates all derived files by re-running all of the necessary tools in the correct order. It is somewhat of a brute (畜生的, 沒有理性的) force solution, but it works very 
well, particularly if you are not trying to accommodate (能容納, 向...提供)
other maintainers, or regular maintenance that would render (執行)
this command bothersome (令人討厭的, 麻煩的). 


The alternative is Automake's `maintainer mode'.
By invoking the AM\_{}
MAINTAINER\_{}MODE macro from `configure.in',
automake will activate an `\verb+--enable-maintainer-mode+' option 
in `configure'.
This is explained at length in chapter \ref{C_Bootstrapping} Bootstrapping,
page \pageref{C_Bootstrapping}. 

\section{Packaging Generated Files}


The debate (討論, 辯論) about what to do with generated files is one which is 
keenly (敏銳地, 熱心地) contested (爭論, 比賽) on the relevant Internet 
mailing lists. There are two points\marginpar{以下兩段在討論如何處理被
autotools 所產生的檔案, 要放在套件裡, 還是不該放在套件裡。}
of view and I will present both of them to you so that you can try 
to decide what the best policy is for your project. 


One argument is that generated files should not be included with a package, but rather only the `preferred form' of the source code should be included. By this definition, `configure' is a derived file, just like an object file, and it should not be included in the package. Thus, the user should use the GNU Autotools to bootstrap themselves prior to (prior to 在...以前) building the package. I believe there is some merit (長處,優點,價值) to this
purist (純粹主義者;純粹派藝術家) approach (方法,門徑;態度,接近,靠近;即將達到),
as it discourages the practice of packaging derived files. 


The other argument is that the advantages of providing these files can far 
outweigh (比...更重要 (或更有價值等) ) the violation (違反; 違背; 違犯) of good 
software engineering practice mentioned above. By including the generated files,
users have the convenience of not needing to be concerned with keeping up to 
date with all of the different versions of the tools in active use. This is 
especially (特別; 尤其; 格外; 主要) true for Autoconf, as `configure' scripts 
are 
often generated by maintainers using locally modified versions of autoconf and 
locally installed macros. If `configure' were regenerated by the user, the 
result could be different to that intended (打算中的, 預期的, 未來的).
Of course, 
this is poor (粗劣的, 蹩腳的) practice, but it happens to (happen to 發生於)
reflect reality (現實, 真實). 


I believe the answer is to include generated files in the package when the 
package is going to be distributed to a wide user community
(ie. the general public). For in-house (內部的, 自力設計、 製造的) packages,
the former argument might make more sense, since the tools may also be 
held under version control. 

\section{Documentation and ChangeLogs}\label{S_Documentation_and_ChangeLogs}


As with any software project, it is important to maintain documentation as the 
project evolves -- the documentation must reflect the current state of the 
software, but it must also accurately (準確地; 精確地; 正確無誤地) record the 
changes that have been made in the past. The GNU coding standard 
rigorously (嚴厲地;殘酷地) enforces (堅持) the maintenance of documentation. Automake, in fact, implements some of the standard by checking for the presence of a `ChangeLog' file when automake is run! 


A number of files exist, with standardized filenames, for storing documentation in GNU packages. The complete GNU coding standard, which offers some useful insights, can be found at http://www.gnu.org/prep/standards.html. 


Other projects, including in-house projects, can use these same tried-and-true techniques. The purpose of most of the standard documentation files was outlined earlier See section \ref{S_Generated_Output_Files} Generated Output Files,
page \pageref{S_Generated_Output_Files}, but the `ChangeLog'
deserves (應受) additional treatment. 


When recording changes in a `ChangeLog', one entry is made per person. Logical 
changes are grouped together, while logically distinct (有區別的) changes
(ie. `change sets') are separated by a single blank line. Here is an example 
from Automake's own `ChangeLog': 


 
\begin{Verbatim}[frame=single]
1999-11-21  Tom Tromey  <tromey@cygnus.com>

   * automake.in (finish_languages): Only generate suffix rule
     when not doing dependency tracking.

   * m4/init.m4 (AM_INIT_AUTOMAKE): Use AM_MISSING_INSTALL_SH.
   * m4/missing.m4 (AM_MISSING_INSTALL_SH): New macro.

   * depend2.am: Use @SOURCE@, @OBJ@, @LTOBJ@, @OBJOBJ@,
     and @BASE@.  Always use -o.
\end{Verbatim}


Another important point to make about `ChangeLog' entries is that they should 
be brief. It is not necessary for an entry to explain in details why a change 
was made, but rather what the change was. If a change is not 
straightforward (坦率地,直截了當地) then the explanation of why belongs in the 
source code itself. The GNU coding standard offers the complete set of 
guidelines for keeping `ChangeLog's. Although any text editor can be used to 
create ChangeLog entries, Emacs provides a major mode to help you write them.

